<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.20" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const useChoice = localStorage.getItem('vuepress-color-scheme')
      const systemStatus =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (useChoice === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (useChoice === 'dark' || systemStatus) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>36 | HTTPS：让数据传输更安全 | 浏览器工作原理</title><meta name="description" content="透过浏览器看懂前端本质">
    <link rel="preload" href="/how-browsers-work/assets/style-BGmF4SdV.css" as="style"><link rel="stylesheet" href="/how-browsers-work/assets/style-BGmF4SdV.css">
    <link rel="modulepreload" href="/how-browsers-work/assets/app-DyIZTd3t.js"><link rel="modulepreload" href="/how-browsers-work/assets/36.html-D-eDvICS.js">
    <link rel="prefetch" href="/how-browsers-work/assets/index.html-BePBZI_K.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/01.html-BG75gLvs.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/02.html-NjJJApek.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/03.html-C68_um3b.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/04.html-DSHXs99J.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/05.html-CRuh8ELn.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/06.html-Coe1lARX.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/07.html-3OWD30Vl.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/08.html-BNTXYsOh.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/09.html-1Y2Gav6a.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/10.html-B-KC0iPb.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/11.html-YtVjeSpE.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/12.html-BjnAkMow.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/13.html-Saxwd39l.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/14.html-9_X0Kr1G.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/15.html-FuaRWZzV.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/16.html-BnPQNCuC.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/17.html-BCYXLxUT.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/18.html-CNvdSqM6.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/19.html-Co72VLkH.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/20.html-B2QkSpW3.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/21.html-CEZwuHjJ.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/22.html-B9-i3O_C.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/23.html-BCleSA48.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/24.html-DYQbig2l.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/25.html-049uq0nG.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/26.html-CbEz1Diz.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/27.html-Db44i6MY.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/28.html-PvPOfayN.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/29.html-CRL78H1B.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/30.html-DQaWICRx.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/31.html-551tiLUP.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/32.html-DHPy_ipd.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/33.html-C9HfAi04.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/34.html-D5oRX49w.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/35.html-B0rZD787.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/01.html-BMc3nbrF.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/404.html-DAuF7Xw-.js" as="script"><link rel="prefetch" href="/how-browsers-work/assets/Post-DNA6X-DI.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/how-browsers-work/"><img class="vp-site-logo" src="https://vuejs.press/images/hero.png" alt="浏览器工作原理"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">浏览器工作原理</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/how-browsers-work/" aria-label="首页"><!--[--><!--[--><!--]--><!--]-->首页<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/how-browsers-work/guide/01.html" aria-label="全文阅读"><!--[--><!--[--><!--]--><!--]-->全文阅读<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/how-browsers-work/" aria-label="首页"><!--[--><!--[--><!--]--><!--]-->首页<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/how-browsers-work/guide/01.html" aria-label="全文阅读"><!--[--><!--[--><!--]--><!--]-->全文阅读<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">宏观视角下的浏览器 (6讲) <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/01.html" aria-label="01 | Chrome架构：仅仅打开了1个页面，为什么有4个进程？"><!--[--><!--[--><!--]--><!--]-->01 | Chrome架构：仅仅打开了1个页面，为什么有4个进程？<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/02.html" aria-label="02 | TCP协议：如何保证页面文件能被完整送达浏览器？"><!--[--><!--[--><!--]--><!--]-->02 | TCP协议：如何保证页面文件能被完整送达浏览器？<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/03.html" aria-label="03 | HTTP请求流程：为什么很多站点第二次打开速度会很快？"><!--[--><!--[--><!--]--><!--]-->03 | HTTP请求流程：为什么很多站点第二次打开速度会很快？<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/04.html" aria-label="04 | 导航流程：从输入URL到页面展示，这中间发生了什么？"><!--[--><!--[--><!--]--><!--]-->04 | 导航流程：从输入URL到页面展示，这中间发生了什么？<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/05.html" aria-label="05 | 渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面..."><!--[--><!--[--><!--]--><!--]-->05 | 渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面...<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/06.html" aria-label="06 | 渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面..."><!--[--><!--[--><!--]--><!--]-->06 | 渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面...<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">浏览器中的JavaScript执行机制 (5讲) <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/07.html" aria-label="07 | 变量提升：JavaScript代码是按顺序执行的吗？"><!--[--><!--[--><!--]--><!--]-->07 | 变量提升：JavaScript代码是按顺序执行的吗？<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/08.html" aria-label="08 | 调用栈：为什么JavaScript代码会出现栈溢出？"><!--[--><!--[--><!--]--><!--]-->08 | 调用栈：为什么JavaScript代码会出现栈溢出？<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/09.html" aria-label="09 | 块级作用域：var缺陷以及为什么要引入let和const？"><!--[--><!--[--><!--]--><!--]-->09 | 块级作用域：var缺陷以及为什么要引入let和const？<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/10.html" aria-label="10 | 作用域链和闭包：代码中出现相同的变量，JavaScript引擎是如..."><!--[--><!--[--><!--]--><!--]-->10 | 作用域链和闭包：代码中出现相同的变量，JavaScript引擎是如...<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/11.html" aria-label="11 | this：从JavaScript执行上下文的视角讲清楚this"><!--[--><!--[--><!--]--><!--]-->11 | this：从JavaScript执行上下文的视角讲清楚this<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">V8工作原理 (3讲) <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/12.html" aria-label="12 | 栈空间和堆空间：数据是如何存储的？"><!--[--><!--[--><!--]--><!--]-->12 | 栈空间和堆空间：数据是如何存储的？<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/13.html" aria-label="13 | 垃圾回收：垃圾数据是如何自动回收的？"><!--[--><!--[--><!--]--><!--]-->13 | 垃圾回收：垃圾数据是如何自动回收的？<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/14.html" aria-label="14 | 编译器和解释器：V8是如何执行一段JavaScript代码的？"><!--[--><!--[--><!--]--><!--]-->14 | 编译器和解释器：V8是如何执行一段JavaScript代码的？<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">浏览器中的页面循环系统 (6讲) <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/15.html" aria-label="15 | 消息队列和事件循环：页面是怎么“活”起来的？"><!--[--><!--[--><!--]--><!--]-->15 | 消息队列和事件循环：页面是怎么“活”起来的？<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/16.html" aria-label="16 | WebAPI：setTimeout是如何实现的？"><!--[--><!--[--><!--]--><!--]-->16 | WebAPI：setTimeout是如何实现的？<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/17.html" aria-label="17 | WebAPI：XMLHttpRequest是怎么实现的？"><!--[--><!--[--><!--]--><!--]-->17 | WebAPI：XMLHttpRequest是怎么实现的？<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/18.html" aria-label="18 | 宏任务和微任务：不是所有任务都是一个待遇"><!--[--><!--[--><!--]--><!--]-->18 | 宏任务和微任务：不是所有任务都是一个待遇<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/19.html" aria-label="19 | Promise：使用Promise，告别回调函数"><!--[--><!--[--><!--]--><!--]-->19 | Promise：使用Promise，告别回调函数<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/20.html" aria-label="20 | async/await：使用同步的方式去写异步代码"><!--[--><!--[--><!--]--><!--]-->20 | async/await：使用同步的方式去写异步代码<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">浏览器中的页面 (8讲) <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/21.html" aria-label="21 | Chrome开发者工具：利用网络面板做性能分析"><!--[--><!--[--><!--]--><!--]-->21 | Chrome开发者工具：利用网络面板做性能分析<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/22.html" aria-label="22 | DOM树：JavaScript是如何影响DOM树构建的？"><!--[--><!--[--><!--]--><!--]-->22 | DOM树：JavaScript是如何影响DOM树构建的？<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/23.html" aria-label="23 | 渲染流水线：CSS如何影响首次加载时的白屏时间？"><!--[--><!--[--><!--]--><!--]-->23 | 渲染流水线：CSS如何影响首次加载时的白屏时间？<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/24.html" aria-label="24 | 分层和合成机制：为什么CSS动画比JavaScript高效？"><!--[--><!--[--><!--]--><!--]-->24 | 分层和合成机制：为什么CSS动画比JavaScript高效？<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/25.html" aria-label="25 | 页面性能：如何系统地优化页面？"><!--[--><!--[--><!--]--><!--]-->25 | 页面性能：如何系统地优化页面？<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/26.html" aria-label="26 | 虚拟DOM：虚拟DOM和实际的DOM有何不同？"><!--[--><!--[--><!--]--><!--]-->26 | 虚拟DOM：虚拟DOM和实际的DOM有何不同？<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/27.html" aria-label="27 | 渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？"><!--[--><!--[--><!--]--><!--]-->27 | 渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/28.html" aria-label="28 | WebComponent：像搭积木一样构建Web应用"><!--[--><!--[--><!--]--><!--]-->28 | WebComponent：像搭积木一样构建Web应用<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">浏览器中的网络 (3讲) <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/29.html" aria-label="29 | HTTP/1: HTTP性能优化"><!--[--><!--[--><!--]--><!--]-->29 | HTTP/1: HTTP性能优化<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/30.html" aria-label="30 | HTTP/2: 如何提升网络速度？"><!--[--><!--[--><!--]--><!--]-->30 | HTTP/2: 如何提升网络速度？<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/31.html" aria-label="31 | HTTP/3: 甩掉TCP、TLS的包袱，构建高效网络"><!--[--><!--[--><!--]--><!--]-->31 | HTTP/3: 甩掉TCP、TLS的包袱，构建高效网络<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading active">浏览器安全 (5讲) <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/32.html" aria-label="32 | 同源策略：为什么XMLHttpRequest不能跨域请求资源？"><!--[--><!--[--><!--]--><!--]-->32 | 同源策略：为什么XMLHttpRequest不能跨域请求资源？<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/33.html" aria-label="33 | 跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？"><!--[--><!--[--><!--]--><!--]-->33 | 跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/34.html" aria-label="34 | CSRF攻击：陌生链接不要随便点"><!--[--><!--[--><!--]--><!--]-->34 | CSRF攻击：陌生链接不要随便点<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/how-browsers-work/guide/35.html" aria-label="35 | 安全沙箱：页面和系统之间的隔离墙"><!--[--><!--[--><!--]--><!--]-->35 | 安全沙箱：页面和系统之间的隔离墙<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link route-link-active auto-link vp-sidebar-item active" href="/how-browsers-work/guide/36.html" aria-label="36 | HTTPS：让数据传输更安全"><!--[--><!--[--><!--]--><!--]-->36 | HTTPS：让数据传输更安全<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div vp-content><!--[--><!--]--><div><h1 id="_36-https-让数据传输更安全" tabindex="-1"><a class="header-anchor" href="#_36-https-让数据传输更安全"><span>36 | HTTPS：让数据传输更安全</span></a></h1><p>浏览器安全主要划分为三大块内容：页面安全、系统安全和网络安全。前面我们用四篇文章介绍了页面安全和系统安全，也聊了浏览器和 Web 开发者是如何应对各种类型的攻击，本文是我们专栏的最后一篇，我们就接着来聊聊网络安全协议 HTTPS。</p><p>我们先从 HTTP 的明文传输的特性讲起，在上一个模块的三篇文章中我们分析过，起初设计 HTTP 协议的目的很单纯，就是为了传输超文本文件，那时候也没有太强的加密传输的数据需求，所以 HTTP 一直保持着明文传输数据的特征。但这样的话，在传输过程中的每一个环节，数据都有可能被窃取或者篡改，这也意味着你和服务器之间还可能有个中间人，你们在通信过程中的一切内容都在中间人的掌握中，如下图：</p><p><img src="https://static001.geekbang.org/resource/image/11/e2/118ced11537bd1e257f8df09380f33e2.png" alt="中间人攻击"></p><p>从上图可以看出，我们使用 HTTP 传输的内容很容易被中间人窃取、伪造和篡改，通常我们把这种攻击方式称为<strong>中间人攻击</strong>。</p><p>具体来讲，在将 HTTP 数据提交给 TCP 层之后，数据会经过用户电脑、WiFi 路由器、运营商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。比如用户电脑被黑客安装了恶意软件，那么恶意软件就能抓取和篡改所发出的 HTTP 请求的内容。或者用户一不小心连接上了 WiFi 钓鱼路由器，那么数据也都能被黑客抓取或篡改。</p><h2 id="在-http-协议栈中引入安全层" tabindex="-1"><a class="header-anchor" href="#在-http-协议栈中引入安全层"><span>在 HTTP 协议栈中引入安全层</span></a></h2><p>鉴于 HTTP 的明文传输使得传输过程毫无安全性可言，且制约了网上购物、在线转账等一系列场景应用，于是倒逼着我们要引入<strong>加密方案</strong>。</p><p>从 HTTP 协议栈层面来看，我们可以在 TCP 和 HTTP 之间插入一个安全层，所有经过安全层的数据都会被加密或者解密，你可以参考下图：</p><p><img src="https://static001.geekbang.org/resource/image/9e/cf/9e99f797de30a15a11b0e4b4c8f810cf.png" alt="HTTP VS HTTPS"></p><p>从图中我们可以看出 HTTPS 并非是一个新的协议，通常 HTTP 直接和 TCP 通信，HTTPS 则先和安全层通信，然后安全层再和 TCP 层通信。也就是说 HTTPS 所有的安全核心都在安全层，它不会影响到上面的 HTTP 协议，也不会影响到下面的 TCP/IP，因此要搞清楚 HTTPS 是如何工作的，就要弄清楚安全层是怎么工作的。</p><p>总的来说，安全层有两个主要的职责：<strong>对发起 HTTP 请求的数据进行加密操作和对接收到 HTTP 的内容进行解密操作。</strong></p><p>我们知道了安全层最重要的就是加解密，那么接下来我们就利用这个安全层，一步一步实现一个从简单到复杂的 HTTPS 协议。</p><h2 id="第一版-使用对称加密" tabindex="-1"><a class="header-anchor" href="#第一版-使用对称加密"><span>第一版：使用对称加密</span></a></h2><p>提到加密，最简单的方式是使用对称加密。所谓<strong>对称加密是指加密和解密都使用的是相同的密钥</strong>。</p><p>了解了对称加密，下面我们就使用对称加密来实现第一版的 HTTPS。</p><p>要在两台电脑上加解密同一个文件，我们至少需要知道加解密方式和密钥，因此，在 HTTPS 发送数据之前，浏览器和服务器之间需要协商加密方式和密钥，过程如下所示：</p><p><img src="https://static001.geekbang.org/resource/image/d8/3b/d86648267d5504c7813b2d692620503b.png" alt="使用对称加密实现 HTTPS"></p><p>通过上图我们可以看出，HTTPS 首先要协商加解密方式，这个过程就是 HTTPS 建立安全连接的过程。为了让加密的密钥更加难以破解，我们让服务器和客户端同时决定密钥，具体过程如下：</p><ul><li><p>浏览器发送它所支持的加密套件列表和一个随机数 client-random，这里的<strong>加密套件是指加密的方法</strong>，加密套件列表就是指浏览器能支持多少种加密方法列表。</p></li><li><p>服务器会从加密套件列表中选取一个加密套件，然后还会生成一个随机数 service-random，并将 service-random 和加密套件列表返回给浏览器。</p></li><li><p>最后浏览器和服务器分别返回确认消息。</p></li></ul><p>这样浏览器端和服务器端都有相同的 client-random 和 service-random 了，然后它们再使用相同的方法将 client-random 和 service-random 混合起来生成一个密钥 master secret，有了密钥 master secret 和加密套件之后，双方就可以进行数据的加密传输了。</p><p>通过将对称加密应用在安全层上，我们实现了第一个版本的 HTTPS，虽然这个版本能够很好地工作，但是其中传输 client-random 和 service-random 的过程却是明文的，这意味着黑客也可以拿到协商的加密套件和双方的随机数，由于利用随机数合成密钥的算法是公开的，所以黑客拿到随机数之后，也可以合成密钥，这样数据依然可以被破解，那么黑客也就可以使用密钥来伪造或篡改数据了。</p><h2 id="第二版-使用非对称加密" tabindex="-1"><a class="header-anchor" href="#第二版-使用非对称加密"><span>第二版：使用非对称加密</span></a></h2><p>不过非对称加密能够解决这个问题，因此接下来我们就利用非对称加密来实现我们第二版的 HTTPS，不过在讨论具体的实现之前，我们先看看什么是非对称加密。</p><p>和对称加密只有一个密钥不同，<strong>非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密。</strong></p><p>在 HTTPS 中，服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥称为<strong>公钥</strong>，服务器自己留下的那个密钥称为<strong>私钥</strong>。顾名思义，<strong>公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开</strong>。下图是使用非对称加密改造的 HTTPS 协议：</p><p><img src="https://static001.geekbang.org/resource/image/b2/50/b2b893921491c62b29aaddc1d4fa9550.png" alt="非对称加密实现 HTTPS"></p><p>根据该图，我们来分析下使用非对称加密的请求流程。</p><ul><li><p>首先浏览器还是发送加密套件列表给服务器。</p></li><li><p>然后服务器会选择一个加密套件，不过和对称加密不同的是，使用非对称加密时服务器上需要有用于浏览器加密的公钥和服务器解密 HTTP 数据的私钥，由于公钥是给浏览器加密使用的，因此服务器会将加密套件和公钥一道发送给浏览器。</p></li><li><p>最后就是浏览器和服务器返回确认消息。</p></li></ul><p>这样浏览器端就有了服务器的公钥，在浏览器端向服务器端发送数据时，就可以使用该公钥来加密数据。由于公钥加密的数据只有私钥才能解密，所以即便黑客截获了数据和公钥，他也是无法使用公钥来解密数据的。</p><p>因此采用非对称加密，就能保证浏览器发送给服务器的数据是安全的了，这看上去似乎很完美，不过这种方式依然存在两个严重的问题。</p><ul><li><p><strong>第一个是非对称加密的效率太低</strong>。这会严重影响到加解密数据的速度，进而影响到用户打开页面的速度。</p></li><li><p><strong>第二个是无法保证服务器发送给浏览器的数据安全</strong>。虽然浏览器端可以使用公钥来加密，但是服务器端只能采用私钥来加密，私钥加密只有公钥能解密，但黑客也是可以获取得到公钥的，这样就不能保证服务器端数据的安全了。</p></li></ul><h2 id="第三版-对称加密和非对称加密搭配使用" tabindex="-1"><a class="header-anchor" href="#第三版-对称加密和非对称加密搭配使用"><span>第三版：对称加密和非对称加密搭配使用</span></a></h2><p>基于以上两点原因，我们最终选择了一个更加完美的方案，那就是<strong>在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输</strong>。下图就是改造后的版本：</p><p><img src="https://static001.geekbang.org/resource/image/d5/45/d5cd34dbf3636ebc0e809aa424c53845.png" alt="混合加密实现 HTTPS"></p><p>从图中可以看出，改造后的流程是这样的：</p><ul><li><p>首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random；</p></li><li><p>服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和公钥；</p></li><li><p>浏览器保存公钥，并生成随机数 pre-master，然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据；</p></li><li><p>最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息。</p></li></ul><p>到此为止，服务器和浏览器就有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使用这三组随机数生成<strong>对称密钥</strong>，因为服务器和浏览器使用同一套方法来生成密钥，所以最终生成的密钥也是相同的。</p><p>有了对称加密的密钥之后，双方就可以使用对称加密的方式来传输数据了。</p><p>需要特别注意的一点，<strong>pre-master 是经过公钥加密之后传输的，所以黑客只能获取到使用公钥加密后的 pre-master，而不能获得解密后的 pre-master, 这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程中的数据了</strong>。</p><h2 id="第四版-添加数字证书" tabindex="-1"><a class="header-anchor" href="#第四版-添加数字证书"><span>第四版：添加数字证书</span></a></h2><p>通过对称和非对称混合方式，我们完美地实现了数据的加密传输。不过这种方式依然存在着问题，比如我要打开极客时间的官网，但是黑客通过 DNS 劫持将极客时间官网的 IP 地址替换成了黑客的 IP 地址，这样我访问的其实是黑客的服务器了，黑客就可以在自己的服务器上实现公钥和私钥，而对浏览器来说，它完全不知道现在访问的是个黑客的站点。</p><p>所以我们还需要服务器向浏览器提供证明“我就是我”，那怎么证明呢？</p><p>这里我们结合实际生活中的一个例子，比如你要买房子，首先你需要给房管局提交你买房的材料，包括银行流水、银行证明、身份证等，然后房管局工作人员在验证无误后，会发给你一本盖了章的房产证，房产证上包含了你的名字、身份证号、房产地址、实际面积、公摊面积等信息。</p><p>在这个例子中，你之所以能证明房子是你自己的，是因为引进了房管局这个<strong>权威机构</strong>，并通过这个权威机构给你颁发一个<strong>证书</strong>：房产证。</p><p>同理，极客时间要证明这个服务器就是极客时间的，也需要使用权威机构颁发的证书，这个权威机构称为 <strong>CA（Certificate Authority）</strong>，颁发的证书就称为<strong>数字证书（Digital Certificate)</strong>。</p><p>对于浏览器来说，数字证书有两个作用：一个是通过数字证书向浏览器证明服务器的身份，另一个是数字证书里面包含了服务器公钥。</p><p>接下来我们看看含有数字证书的 HTTPS 的请求流程，你可以参考下图：</p><p><img src="https://static001.geekbang.org/resource/image/77/af/77c852ff2202b2b7bb3299a96a0f4aaf.png" alt="完整的 HTTPS 请求流程"></p><p>相较于第三版的 HTTPS 协议，这里主要有两点改变：</p><ol><li><p>服务器没有直接返回公钥给浏览器，而是返回了数字证书，而公钥正是包含在数字证书中的；</p></li><li><p>在浏览器端多了一个证书验证的操作，验证了证书之后，才继续后续流程。</p></li></ol><p>通过引入数字证书，我们就实现了服务器的身份认证功能，这样即便黑客伪造了服务器，但是由于证书是没有办法伪造的，所以依然无法欺骗用户。</p><h2 id="数字证书的申请和验证" tabindex="-1"><a class="header-anchor" href="#数字证书的申请和验证"><span>数字证书的申请和验证</span></a></h2><p>通过上面四个版本的迭代，我们实现了目前的 HTTPS 架构。</p><p>在第四版的 HTTPS 中，我们提到过，有了数字证书，黑客就无法欺骗用户了，不过我们并没有解释清楚如何通过数字证书来证明用户身份，所以接下来我们再来把这个问题解释清楚。</p><h2 id="如何申请数字证书" tabindex="-1"><a class="header-anchor" href="#如何申请数字证书"><span>如何申请数字证书</span></a></h2><p>我们先来看看如何向 CA 申请证书。比如极客时间需要向某个 CA 去申请数字证书，通常的申请流程分以下几步：</p><ul><li><p>首先极客时间需要准备一套私钥和公钥，私钥留着自己使用；</p></li><li><p>然后极客时间向 CA 机构提交公钥、公司、站点等信息并等待认证，这个认证过程可能是收费的；</p></li><li><p>CA 通过线上、线下等多种渠道来验证极客时间所提供信息的真实性，如公司是否存在、企业是否合法、域名是否归属该企业等；</p></li><li><p>如信息审核通过，CA 会向极客时间签发认证的数字证书，包含了极客时间的公钥、组织信息、CA 的信息、有效时间、证书序列号等，这些信息都是明文的，同时包含一个 CA 生成的签名。</p></li></ul><p>这样我们就完成了极客时间数字证书的申请过程。前面几步都很好理解，不过最后一步数字签名的过程还需要解释下：首先 CA 使用 <strong>Hash 函数</strong>来计算极客时间提交的明文信息，并得出<strong>信息摘要</strong>；然后 CA 再使用它的私钥对信息摘要进行加密，<strong>加密后的密文就是 CA 颁给极客时间的数字签名</strong>。这就相当于房管局在房产证上盖的章，这个章是可以去验证的，同样我们也可以通过数字签名来验证是否是该 CA 颁发的。</p><h2 id="浏览器如何验证数字证书" tabindex="-1"><a class="header-anchor" href="#浏览器如何验证数字证书"><span>浏览器如何验证数字证书</span></a></h2><p>有了 CA 签名过的数字证书，当浏览器向极客时间服务器发出请求时，服务器会返回数字证书给浏览器。</p><p>浏览器接收到数字证书之后，会对数字证书进行验证。首先浏览器读取证书中相关的明文信息，采用 CA 签名时相同的 Hash 函数来计算并得到<strong>信息摘要 A</strong>；然后再利用对应 CA 的公钥解密签名数据，得到<strong>信息摘要 B</strong>；对比信息摘要 A 和信息摘要 B，如果一致，则可以确认证书是合法的，即证明了这个服务器是极客时间的；同时浏览器还会验证证书相关的域名信息、有效时间等信息。</p><p>这时候相当于验证了 CA 是谁，但是这个 CA 可能比较小众，浏览器不知道该不该信任它，然后浏览器会继续查找给这个 CA 颁发证书的 CA，再以同样的方式验证它上级 CA 的可靠性。通常情况下，操作系统中会内置信任的顶级 CA 的证书信息（包含公钥），如果这个 CA 链中没有找到浏览器内置的顶级的 CA，证书也会被判定非法。</p><p>另外，在申请和使用证书的过程中，还需要注意以下三点：</p><ol><li><p>申请数字证书是不需要提供私钥的，要确保私钥永远只能由服务器掌握；</p></li><li><p>数字证书最核心的是 CA 使用它的私钥生成的数字签名；</p></li><li><p>内置 CA 对应的证书称为根证书，根证书是最权威的机构，它们自己为自己签名，我们把这称为自签名证书。</p></li></ol><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>好了，今天就介绍到这里，下面我来总结下本文的主要内容。</p><p>由于 HTTP 的明文传输特性，在传输过程中的每一个环节，数据都有可能被窃取或者篡改，这倒逼着我们需要引入加密机制。于是我们在 HTTP 协议栈的 TCP 和 HTTP 层之间插入了一个安全层，负责数据的加密和解密操作。</p><p>我们使用对称加密实现了安全层，但是由于对称加密的密钥需要明文传输，所以我们又将对称加密改造成了非对称加密。但是非对称加密效率低且不能加密服务器到浏览器端的数据，于是我们又继续改在安全层，采用对称加密的方式加密传输数据和非对称加密的方式来传输密钥，这样我们就解决传输效率和两端数据安全传输的问题。</p><p>采用这种方式虽然能保证数据的安全传输，但是依然没办法证明服务器是可靠的，于是又引入了数字证书，数字证书是由 CA 签名过的，所以浏览器能够验证该证书的可靠性。</p><p>另外百看不如一试，我建议你自己亲手搭建一个 HTTPS 的站点，可以去 freeSSL 申请免费证书。链接我已经放在文中了：</p><p>中文：https://freessl.cn/</p><p>英文：https://www.freessl.com/</p><h2 id="思考时间" tabindex="-1"><a class="header-anchor" href="#思考时间"><span>思考时间</span></a></h2><p>今天留给你的作业：结合前面的文章以及本文，你来总结一下 HTTPS 的握手过程。</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="vp-meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 987042638@qq.com">mmmying</span><!----><!--]--><!--]--></span></div></div></footer><nav class="vp-page-nav" aria-label="page navigation"><a class="route-link auto-link prev" href="/how-browsers-work/guide/35.html" aria-label="35 | 安全沙箱：页面和系统之间的隔离墙"><!--[--><div class="hint"><span class="arrow left"></span> Prev</div><div class="link"><span class="external-link">35 | 安全沙箱：页面和系统之间的隔离墙</span></div><!--]--></a><!----></nav><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/how-browsers-work/assets/app-DyIZTd3t.js" defer></script>
  </body>
</html>
